#!/usr/bin/env python3
import argparse
import base64
import json
import os
import re
import subprocess
import sys
import tempfile
from urllib.parse import urlparse

import requests
from dotenv import load_dotenv

# --- Configuration and Constants ---
# Determine the app directory and load the .env file
APP_DIR = os.path.dirname(os.path.realpath(__file__))
dotenv_path = os.path.join(APP_DIR, ".env")
load_dotenv(dotenv_path=dotenv_path)

JINA_READER_URL = "https://r.jina.ai/"

# --- LLM Logic (Summarization) ---

def _call_gemini(text: str, api_key: str) -> str | None:
    """Sends a request to the Google Gemini API."""
    print("Attempting to use Gemini for summarization...")
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={api_key}"
    headers = {"Content-Type": "application/json"}
    prompt = f"Summarize the following text in polish in a maximum of 5-7 sentences. Focus on the most important information. Text to summarize:\n\n{text}"
    data = {"contents": [{"parts": [{"text": prompt}]}]}

    try:
        response = requests.post(url, headers=headers, json=data, timeout=45)
        response.raise_for_status()
        result = response.json()
        summary = result["candidates"][0]["content"]["parts"][0]["text"]
        return summary.strip()
    except Exception as e:
        print(f"Gemini (summarize) error: {e}", file=sys.stderr)
        return None

def _call_openai(text: str, api_key: str, model: str) -> str | None:
    """Sends a request to the OpenAI API."""
    print(f"Attempting to use OpenAI ({model}) for summarization...")
    # Placeholder for OpenAI logic
    print("OpenAI logic is not yet implemented.", file=sys.stderr)
    return None

def _call_deepseek(text: str, api_key: str, model: str) -> str | None:
    """Sends a request to the DeepSeek API."""
    print(f"Attempting to use DeepSeek ({model}) for summarization...")
    # Placeholder for DeepSeek logic
    print("DeepSeek logic is not yet implemented.", file=sys.stderr)
    return None
    
def _call_ollama(text: str, base_url: str, model: str) -> str | None:
    """Sends a request to a local Ollama server."""
    print(f"Attempting to use Ollama ({model}) for summarization...")
    # Placeholder for Ollama logic
    print("Ollama logic is not yet implemented.", file=sys.stderr)
    return None

def summarize_text(text: str) -> str | None:
    """Summarizes text using LLM providers according to the fallback order."""
    fallback_order = os.getenv("LLM_FALLBACK_ORDER", "gemini,openai").split(',')
    
    for provider in fallback_order:
        summary = None
        if provider == "gemini":
            api_key = os.getenv("GEMINI_API_KEY")
            if api_key and api_key != "Your_Gemini_API_Key":
                summary = _call_gemini(text, api_key)
        elif provider == "openai":
            api_key = os.getenv("OPENAI_API_KEY")
            model = os.getenv("OPENAI_MODEL", "gpt-4o")
            if api_key and api_key != "Your_OpenAI_API_Key":
                summary = _call_openai(text, api_key, model)
        # ... (other providers)

        if summary:
            print(f"Summary generated by: {provider}")
            return summary
            
    print("Failed to get summary from any configured LLM.", file=sys.stderr)
    return None

# --- Content Processing ---

def is_url(text: str) -> bool:
    """Checks if the given text is a valid URL."""
    try:
        result = urlparse(text)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False

def get_content_from_url(url: str) -> str:
    """Fetches and returns the main content of a webpage using Jina AI Reader."""
    print(f"Fetching content from: {url} ...")
    try:
        response = requests.get(f"{JINA_READER_URL}{url}", timeout=30)
        response.raise_for_status()
        
        full_content = response.text
        print("\n--- Fetched Content (Full) ---")
        print(full_content)
        print("--- End of Content ---\n")

        lines = full_content.split('\n')
        meaningful_lines = [line.strip() for line in lines if len(line.strip()) > 40]
        potential_content = [line for line in meaningful_lines if len(line.split()) > 5 and line.endswith('.')]
        
        if not potential_content:
            parts = full_content.split('\n\n', 2)
            return max(parts, key=len) if len(parts) > 1 else full_content

        return "\n\n".join(potential_content)

    except requests.RequestException as e:
        return f"Error while fetching URL: {e}"

# --- TTS (Text-to-Speech) Logic ---

def _tts_gemini(text: str, temp_filename: str) -> bool:
    """Generates speech using Google Cloud TTS API (treated as Gemini TTS)."""
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key or api_key == "Your_Gemini_API_Key":
        return False
        
    print("Attempting to use Google TTS engine (Gemini/Cloud)...")
    url = f"https://texttospeech.googleapis.com/v1/text:synthesize?key={api_key}"
    headers = {"Content-Type": "application/json"}
    
    # Note: Using the standard Google Cloud TTS API. If a dedicated
    # Gemini TTS endpoint becomes available, this logic should be updated.
    data = {
        "input": {"text": text},
        "voice": {"languageCode": "pl-PL", "name": "pl-PL-Wavenet-A"},
        "audioConfig": {"audioEncoding": "MP3"}
    }
    
    try:
        response = requests.post(url, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        audio_content = response.json().get("audioContent")
        if not audio_content:
            print("Google TTS Error: No audio content in response.", file=sys.stderr)
            return False

        with open(temp_filename, "wb") as f:
            f.write(base64.b64decode(audio_content))
        return True

    except Exception as e:
        print(f"Google TTS Error: {e}", file=sys.stderr)
        return False

def _tts_gtts(text: str, temp_filename: str) -> bool:
    """Generates speech using the gTTS library (fallback)."""
    from gtts import gTTS
    print("Attempting to use gTTS engine (fallback)...")
    try:
        tts = gTTS(text, lang='pl')
        tts.save(temp_filename)
        return True
    except Exception as e:
        print(f"gTTS Error: {e}", file=sys.stderr)
        return False

def read_aloud(text: str):
    """Converts text to speech and plays it, using configured TTS engines."""
    if not text.strip():
        print("No text to read.")
        return

    print("Preparing speech...")
    fallback_order = os.getenv("TTS_FALLBACK_ORDER", "gtts,gemini").split(',')
    
    temp_file = None
    success = False
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as fp:
            temp_file = fp.name

        for provider in fallback_order:
            if provider == "gemini":
                if _tts_gemini(text, temp_file):
                    success = True
                    break
            elif provider == "gtts":
                if _tts_gtts(text, temp_file):
                    success = True
                    break
        
        if success:
            print("Playing audio...")
            player_command = ["mpg123", "-q", temp_file]
            subprocess.run(player_command, check=True, capture_output=True)
        else:
            print("All configured TTS engines failed.", file=sys.stderr)

    except Exception as e:
        print(f"An error occurred during speech generation or playback: {e}", file=sys.stderr)
        print("Please ensure 'mpg123' is installed (`sudo apt install mpg123`).", file=sys.stderr)
    finally:
        if temp_file and os.path.exists(temp_file):
            os.remove(temp_file)
            print("Temporary file deleted.")

def clean_text(text: str) -> str:
    """Cleans text of common problematic characters and excessive whitespace."""
    replacements = {
        '\u201c': '"',  # “
        '\u201d': '"',  # ”
        '\u2018': "'",  # ‘
        '\u2019': "'",  # ’
        '\u2013': '-',  # – (en-dash)
        '\u2014': '-',  # — (em-dash)
        '\u00a0': ' ',  # non-breaking space
    }
    for old, new in replacements.items():
        text = text.replace(old, new)
    
    # Replace multiple whitespace/newline characters with a single space
    text = re.sub(r'\s+', ' ', text)
    
    return text.strip()

def main():
    """Main script function."""
    parser = argparse.ArgumentParser(
        description="Reads text or web page content aloud, with an option to summarize."
    )
    parser.add_argument(
        "-s", "--summarize",
        action="store_true",
        help="Activates text summarization before reading it aloud using an LLM.",
    )
    parser.add_argument(
        "text_parts",
        nargs='+',
        type=str,
        help="The text to read or a URL. All words will be joined into a single string.",
    )
    args = parser.parse_args()

    # Join all text parts into a single string
    content_to_process = " ".join(args.text_parts)
    
    # Check if the combined text is a single URL
    if len(args.text_parts) == 1 and is_url(content_to_process):
        content_for_reading = get_content_from_url(content_to_process)
    else:
        content_for_reading = content_to_process

    # Clean the text before further processing
    cleaned_content = clean_text(content_for_reading)

    if args.summarize:
        print("Summarization mode activated.")
        summary = summarize_text(cleaned_content)
        if summary:
            # The summary might also need cleaning
            read_aloud(clean_text(summary))
        else:
            print("Summarization failed. Reading original text.", file=sys.stderr)
            read_aloud(cleaned_content)
    else:
        read_aloud(cleaned_content)

if __name__ == "__main__":
    main()
